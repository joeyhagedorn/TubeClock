//
// kbx81's tube clock DMX-512 controller class
// ---------------------------------------------------------------------------
// (c)2019 by kbx81. See LICENSE for details.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>
//
#include <cstdint>
#include "Application.h"
#include "DisplayManager.h"
#include "Dmx-512-Controller.h"
#include "Dmx-512-Packet.h"
#include "Dmx-512-Rx.h"
#include "Hardware.h"
#include "Settings.h"
#include "View.h"


namespace kbxTubeClock {

namespace Dmx512Controller {


// Pitch multiplier - increases the range of available tone pitches/frequencies
//
static const uint8_t cPitchMultiplier = 16;

// Duration of strobe pulses (here, in milliseconds)
//  Time unit depends on frequency of calls to strobeTimer()
static const uint8_t cStrobeDuration = 1;

// Minimum strobe rate when strobe > 0
//
static const uint8_t cStrobeMinimumRate = 20;

// Channel multiplier - used to increase range of intensities and strobe rates
//
static const uint8_t cChannelMultiplier = 4;

// Duration of tones generated by the DMX-512 controller (see cStrobeDuration)
//  Tones are queued by Hardware::tone() so they'll sound constant if needed
static const uint8_t cToneDuration = 60;

// Duration for crossfades as received in DMX-512 packet
//
static uint16_t _fadeDuration = 0;

// Master intensity level
//  10000 = 100%
volatile static uint16_t _masterIntensityLevel = 0;

// Counter for strobe delays
//
volatile static uint16_t _strobeCounter = 0;

// Delay between strobe pulses (here, in milliseconds)
//  Time unit depends on frequency of calls to strobeTimer()
volatile static uint16_t _strobeDelay = cStrobeMinimumRate;


void _dmxExtendedModeController(Dmx512Packet* packet, uint16_t address)
{
  // RgbLed dmxLed[2];
  uint32_t top = 0;
  uint16_t pitch = 0;
  uint8_t level = 0;
  const Application::OperatingMode opMode[] = { Application::OperatingMode::OperatingModeDmx512Display,
                                                Application::OperatingMode::OperatingModeFixedDisplay,
                                                Application::OperatingMode::OperatingModeFixedDisplay,
                                                Application::OperatingMode::OperatingModeFixedDisplay,
                                                Application::OperatingMode::OperatingModeTimerCounter,
                                                Application::OperatingMode::OperatingModeTimerCounter,
                                                Application::OperatingMode::OperatingModeTimerCounter,
                                                Application::OperatingMode::OperatingModeTimerCounter };
  const ViewMode viewMode[] = { ViewMode::ViewMode0,
                                ViewMode::ViewMode0,
                                ViewMode::ViewMode2,
                                ViewMode::ViewMode3,
                                ViewMode::ViewMode0,
                                ViewMode::ViewMode1,
                                ViewMode::ViewMode2,
                                ViewMode::ViewMode3 };

  // first, set the display mode based on channel offset 0
  level = packet->channel(address++) / 32;
  Application::setOperatingMode(opMode[level]);
  Application::setViewMode(viewMode[level]);
 
  // next, set the beeper volume. volume only uses upper three bits
  level = packet->channel(address++) >> 5;
  Hardware::setVolume(level);

  // next, set the beeper pitch/frequency
  pitch = packet->channel(address++);
  Hardware::tone(pitch * cPitchMultiplier, cToneDuration);

  // next, set up strobing if it is enabled (greater than zero)
  _strobeDelay = packet->channel(address++) * cChannelMultiplier;
  if (_strobeDelay > 0)
  {
    _strobeDelay += cStrobeMinimumRate;
  }
  else
  {
    _strobeCounter = 0;
  }
 
  // determine and store the fade duration
  _fadeDuration = (packet->channel(address++) * cChannelMultiplier) + cChannelMultiplier;
 
  // next, determine the master intensity level
  top = (packet->channel(address) * NixieGlyph::cGlyph100Percent);
  _masterIntensityLevel = static_cast<uint16_t>(top / 255);
}


void _dmxStandardModeController(Dmx512Packet* packet, uint16_t address)
{
  uint32_t top = (packet->channel(address) * NixieGlyph::cGlyph100Percent);
  _masterIntensityLevel = static_cast<uint16_t>(top / 255);
}


void initialize()
{
}


void controller()
{
  Dmx512Packet* packet = Dmx512Rx::getLastPacket();
  Settings *pSettings = Application::getSettingsPtr();
  uint16_t address = pSettings->getRawSetting(Settings::Setting::DmxAddress);

  if (packet->startCode() == 0)
  {
    if (pSettings->getSetting(Settings::Setting::SystemOptions, Settings::SystemOptionsBits::DmxExtended) == true)
    {
      _dmxExtendedModeController(packet, address);
    }
    else
    {
      _dmxStandardModeController(packet, address);
    }
  DisplayManager::setMasterIntensity(_masterIntensityLevel);
  }
}


uint16_t fadeDuration()
{
  return _fadeDuration;
}


void strobeTimer()
{
  if (Application::getExternalControlState() == Application::ExternalControl::Dmx512ExtControlEnum)
  {
    if (_strobeDelay > 0)
    {
      _strobeCounter++;
    }

    if (((_masterIntensityLevel > 0) && (_strobeDelay == 0)) ||
        ((_masterIntensityLevel > 0) && (_strobeDelay > 0) && (_strobeCounter > _strobeDelay)))
    {
      DisplayManager::setDisplayBlanking(false);
      if (_strobeCounter > _strobeDelay + cStrobeDuration)
      {
        _strobeCounter = 0;
      }
    }
    else
    {
      DisplayManager::setDisplayBlanking(true);
    }
  }
}


}

}
